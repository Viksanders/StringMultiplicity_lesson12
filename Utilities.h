#pragma once
#include <iostream>
#include <stdlib.h>
#include <vector>

//функции для отладки
void printArr(const int* arr, const int size)
{
    for (int i = 0; i < size; i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}

void printArr(const std::vector<int>& arr)
{
    for (size_t i = 0; i < arr.size(); i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}

void printArrNonZeroIndexes(int* arr, int size)
{
    for (int i = 0; i < size; i++)
    {
        if (arr[i] == 1) std::cout << i << " ";
    }
    std::cout << "\n";
}

//функции для решения задачи
void Erathosphene(const int size, std::vector<int>& output) //функция выдает массив простых чисел от 2 до size, применено Решето Эратосфена (из книги Седжвика)
{
    output.clear();
    const int size_easy = size + 1;
    int* arr = new int[size_easy];
    for (int i = 0; i < size_easy; i++)   //сначала заполняем всю таблицу чисел, здесь индекс - это число, а значение по индексу - его статус
    {
        arr[i] = 1;                 //1 - значит простое, наследующем шаге алгорима вычернем лишнее
    }

    arr[0] = 0; arr[1] = 0;     //0 и 1 не простые числа, вычеркиваем

    for (int i = 2; i < size_easy; i++)       //вычеркиваем числа, кратные индексу i в этом цикле, сами i оставляем, вычеркивая ТОЛЬКО КРАТНОЕ
    {
        if (arr[i] == 0) continue;       //если уже было вычеркнуто, то просто пропускаем этот индекс i
        for (int j = 2; j * i < size_easy; j++) //собственно само вычёркивание
        {
            arr[j * i] = 0;
        }
    }


    for (int i = 0; i < size_easy; i++)   //копируем значения индексов, значения для которых не были вычеркнуты, то есть == 1 - это и есть простые числа
    {
        if (arr[i] == 1) output.push_back(i);
    }

    delete[] arr;
}

int BinarySearch(const std::vector<int>& arr, const int number) //бинарный поиск
{
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right)
    {
        int mid = (left + right) / 2;

        if (arr[mid] == number) return mid;

        if (arr[mid] > number)
        {
            right = mid - 1;
            continue;
        }

        if (arr[mid] < number)
        {
            left = mid + 1;
            continue;
        }
    }
    return -1;
}

void insertionSort(std::vector<int>& arr)      //сортировка вставками
{
    for (size_t i = 1; i < arr.size(); i++)
    {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0)
        {
            if (arr[j] > key) arr[j + 1] = arr[j];
            else break;
            j--;
        }
        arr[j + 1] = key;
    }
}

void FindDividers(const int number, std::vector<int>& dividers)    //функция раскладывает число number на массив простых множителей dividers
{
    dividers.clear();
    int input = number;
    std::vector<int> easy_numbers;  //да, я знаю, что "простое число" будет не easy number, это шутка такая
    Erathosphene(number, easy_numbers);  //массив простых чисел от 2 до number

    if (number == 0)
    {
        dividers.push_back(-1); //обработка специального случая
        return;
    }

    dividers.push_back(1);      //добавляем 1 в начало массива, т.к. это наименьший делитель

    size_t i = 0;
    while (i < easy_numbers.size())    //пробегаем по всему массиву предполагаемых простых делителей
    {
        if (BinarySearch(easy_numbers, input) != -1) //если число input является простым
        {
            dividers.push_back(input);  //добавляем его в массив делителей
            return;                     //и всё
        }
        //если нет, то:
        if ((input % easy_numbers[i]) == 0)  //проверяем, делится ли нацело на простой делитель
        {
            dividers.push_back(easy_numbers[i]);    //если делится нацело - добавляем этот делитель в массив делителей
            input = input / easy_numbers[i];        //делим исходное число на этот делитель, и ищем далее делители уже для результата этого деления
            i = -1;                                  //обнуляем i, чтобы не пропустить повторяющиеся делители
        }
        else
        {
            i++;
            continue;                       //если нацело не делится, то скипаем, и проверяем следующий простой делитель
        }
        i++;
    }
}

int PowOneZero(const int number, const int pow) //функция возводит число в степень 0 или 1, если задать pow = 0, то будет возведение в 0 степень
{                                               //если задать pow >= 1, то вернёт это же число (т.ею будет возведение в степень 1)
    return (pow == 0) ? 1 : number;
}

int PickTheBit(int value, int bit)  //функция определяет какой бит стоит у числа по заданному номеру (0 или 1) зачем это надо
{
    if ((1 << bit) > value) return 0;   //если мы пытаемся взять бит из числа за пределами его диапазона, то возвращаем нулевой бит, т.е. 0
    return (value & (1 << bit)) >> bit;   //например для числа 11dec = 1011bin вызов функции PickTheBit(11, 0) даст 1, потому что (1011 & 0001) >> 0 = 1
    //аналогично PickTheBit(11, 2):   (1011 & 0100) >> 2 = 0;
    //первым действием накладывается маска на исходное число на все биты, кроме ИСКОМОГО, вторым действием искомый бит сдвигается до такой позиции, чтобы
    //чтобы результат был однобитным
}

//функция находит ВСЕ делители числа, простые делители которого записаны в массиве dividers, и записывает их в массив output, без повторов
void FindAllDividers(const std::vector<int>& dividers, std::vector<int>& output)
{
    output.clear();

    int polynomic_number = 1 << dividers.size();    //полиномиальное число (сам так назвал, термина такого не знаю), объяснения в комменте ниже
    /*
    * Чтобы найти все делители числа, нужно взять его простые множители. Пусть A*B*C = D
    * Тогда для нахождения вообще ВСЕХ делителей числа нужно: (A^x1) * (B^x2) * (C^x3)
    * При этом х1, х2, х3 - это степени, либо 0 степень, либо 1 и нужно перебрать ВСЕ КОМБИНАЦИИ СТЕПЕНЕЙ
    * каждая комбинация степеней даст определенный делитель, в том числе и простые множители в случаях, когда только один из иксов ненулевой
    * Как их перебрать? Здесь на помощь приходит функция PickTheBit(int value, int bit)
    * Далее мы просто будем перебирать в цикле числа от нуля до двойки в степени размера массива простых делителей, чтобы получить число, комбинация бит которого
    * даст уникальную комбинацию перемножения простых множителей.
    * Таким образом, для числа, имеющего 3 простых множителя, включая 1 и его самого, будет так
    * 0 0 0 - этот случай мы не рассматриваем, поэтому следующий цикл for начинается сразу с 1
    * 0 0 1
    * 0 1 0
    * 0 1 1
    * 1 0 0
    * 1 0 1
    * 1 1 0
    * 1 1 1 (само это число)
    * 
    * Это моя "авторская идея") Никуда не подстматривал
    */

    for (int i = 1; i < polynomic_number; i++)
    {
        int temp = 1;       //временная переменная, куда будет складываться результат расчета делителя

        for (size_t j = 0; j < dividers.size(); j++)    //пробегаемся по массиву делителей и перемножаем их в соответствии с правилом, описанным выше
        {
            temp = temp * PowOneZero(dividers[j], PickTheBit(i, j)); //Берем текущий простой множитель dividers[j] и в зависимости от вида полинома, задавоемого i,
                                                                    //возводим этот простой множитель либо в степень 0, либо в степень 1
                                                                    //продвигаясь по циклу, получим уникальную комбинацию простых множителей, из которой будет
                                                                    //получен множитель, не являющийся простым числом
        }

        if (BinarySearch(output, temp) == -1)       //бинарный поиск. Если такой множитель уже был добавлен, то не добавляем его, если его ещё не было, то добавляем
        {
            output.push_back(temp);
            insertionSort(output);  //Сортировка именно вставками, потому что массив каждый раз почти упорядочен
                                    //Сортировка нужна, чтобы работал бинарный поиск
        }
        else continue;
    }
}

//--------------------------------------------------------------------------------------------------------------------------------------------------//

int FindKmax(const std::string input)   //Основное задание
{
    //проверка не пустая ли строка, или из одного символа
    if ((input.length() == 0) || (input.length() == 1)) return -1;

    //проверка случая, когда вся строка это один символ, тут всё просто
    //Вот тут я не совсем понял, надо было выдавать 1 или всё-таки -1. Выдал -1, но это легко поменять, если что
    char cmp = input[0];
    bool equal = true;
    for (size_t i = 1; i < input.length(); i++)
    {
        if (input[i] != cmp)
        {
            equal = false;
            break;
        }
    }
    if (equal) return -1;

    //дальше обычная работа алгоритма
    std::vector<int> easy_dividers;
    FindDividers(input.length(), easy_dividers); //Найдём простые числа, являющиеся делителями значения длины строки

    std::vector<int> all_dividers;
    FindAllDividers(easy_dividers, all_dividers);    //теперь на основании простых делителей вычислим вообще все делители числа-длины строки
    //printArr(all_dividers);

    for (size_t i = 1; i < all_dividers.size() - 1; i++)  //первый и последний элементы массива делителей не берем, так как это единица и сама длина строки
    {                                                                                                   //а эти случаи нас не интересуют
        size_t j = all_dividers[i];    //присваиваем правому краю картеки, которая будет ехать по строке, текущее значение делителя строки
        size_t k = 0;    //левый край каретки
        bool flag = true;   //флаг, сигнализирующей об успехе
        while (j < input.length())   //проверяем, пока каретка не стукнется об конец строки
        {
            if (input[k] == input[j])   //посимвольно сравниваем соседние подстроки
            {
                j++;    //если совпадает, то двигаем левый и правый край каретки дальше по строке и продолжаем цикл
                k++;
                continue;
            }
            else
            {
                flag = false;   //ставим флаг, что для данного делителя строки операция провалилась
                break;          //в противном случае скипаем
            }
        }
        //std::cout << "Flag: " << flag << "\n";
        if (flag) return all_dividers[i];     //если операция успешно заверщена, то найденный i и будет наибольшим делителем строки, или как там это в задании называлось
    }

    return -1;  //Если нигде не сработал ретёрн, значит ничего не было найдено, значит кратность отсутствует и выдаём -1
}
